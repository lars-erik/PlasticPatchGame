<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { width: 100%; height: 100% }
        #topbar {
            position: absolute;
            right: 10px;
            top: 10px;
            color: white;
        }
    </style>
</head>
<body>
    <script src="scripts/three.js"></script>
<script src="scripts/perlin.js"></script>
<div id="topbar">
    Space: 5
</div>
<script>

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1000);
    var vFOV = THREE.Math.degToRad(camera.fov); // convert vertical fov to radians
    var height = 2 * Math.tan(vFOV / 2) * 100; // visible height
    var width = height * camera.aspect;           // visible width
    var lookatX = width / 2;
    var lookatY = height / 2;
    var noiseSize = 5;
    var noiseSet = new noise.perlin(noiseSize);
    var noiseScale = noiseSize / width;

    var xScale = width / window.innerWidth;
    var yScale = height / window.innerHeight;

    var gridUnit = width / 20;

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(lookatX, lookatY, 100);
    camera.lookAt(new THREE.Vector3(lookatX, lookatY, 0));

    scene.background = new THREE.Color(0x000088);

    function Trash(scene) {
        let shape = new THREE.Shape();
        let material = new THREE.MeshBasicMaterial({
            color: Math.random() * 0xffffff
        });
        let points = 3 + parseInt(Math.random() * 3);
        let angles = [];
        for (let i = 0; i < points; i++) {
            angles.push(Math.random() * Math.PI * 2);
        }
        angles.sort();
        let startPos = [Math.cos(angles[0]), Math.sin(angles[0])];
        shape.moveTo(startPos[0], startPos[1]);

        for (let i = 1; i < points; i++) {
            shape.lineTo(Math.cos(angles[i]), Math.sin(angles[i]));
        }
        shape.lineTo(startPos[0], startPos[1]);

        let geometry = new THREE.ShapeGeometry(shape);
        this.line = new THREE.Mesh(geometry, material);
        this.line.scale.set(3, 3, 0.1);

        scene.add(this.line);

        this.line.position.set(-10, height / 2 + (Math.random() * height / 5) - (height / 10 * Math.random()), 0);
        this.vector = new THREE.Vector3(.001, Math.random() * height, 0);

        this.box = new THREE.Box3();
        this.box.setFromObject(this.line);

        this.update = function () {
            var ang = Math.atan(this.vector.y);
            var force = noiseSet.noise([Math.abs(this.line.position.x * noiseScale), Math.abs(this.line.position.y * noiseScale)]);
            var newAng = ang + force;
            var newVector = new THREE.Vector3(Math.sin(newAng) * .1, Math.cos(newAng) * -.1, 0);
            this.line.position.add(newVector);
            this.box.setFromObject(this.line);

        }
    }

    function Boat(scene) {

        var spriteMap = new THREE.TextureLoader().load( "Images/Boat.png" );
        var spriteMaterial = new THREE.SpriteMaterial( { map: spriteMap, color: 0xffffff } );
        var sprite = new THREE.Sprite( spriteMaterial );
        sprite.scale.set(20, 40, 0);
        sprite.position.set(0, 3, 1);

        var curve1 = new THREE.EllipseCurve(
            0,  -7,            // ax, aY
            7, 7,           // xRadius, yRadius
            0,  2 * Math.PI,  // aStartAngle, aEndAngle
            false,            // aClockwise
            0                 // aRotation
        );

        var curveGeo = new THREE.BufferGeometry().setFromPoints(curve1.getPoints(50));
        var curveMat = new THREE.LineBasicMaterial( { color : 0x000088 } );

        // Create the final object to add to the scene
        var ellipse = new THREE.Line( curveGeo, curveMat );

        ellipse.position.set(0, 0, -1);

        this.obj = new THREE.Object3D();
        this.obj.add(ellipse);
        this.obj.add(sprite);

        this.obj.position.set(width / 2, height / 2, 1);

        scene.add(this.obj);

        this.ellipse = ellipse;
        this.box = new THREE.Box3();
        this.fullBox = new THREE.Box3();

        this.target = this.obj.position.clone();

        this.lookatTarget = function() {
            let ang = 0;
            if (this.target.x > this.obj.position.x) {
                let opp = this.target.y - this.obj.position.y;
                let hyp = Math.sqrt(Math.pow(opp, 2) + Math.pow(this.target.x - this.obj.position.x, 2));
                let sin = opp / hyp;
                ang = Math.asin(sin) - Math.PI / 2;
            } else {
                let opp = this.obj.position.y - this.target.y;
                let adj = this.obj.position.x - this.target.x;
                let tan = opp / adj;
                ang = Math.atan(tan) + Math.PI / 2;
            }
            this.vectorAngle = ang;
            spriteMaterial.rotation = ang;
            this.obj.setRotationFromAxisAngle(new THREE.Vector3(0, 0, 1), ang);
        }

        this.vector = new THREE.Vector3(0, 0, 0);

        this.setTarget = function (x, y) {
            let xDist = Math.abs(this.target.x - x);
            let yDist = Math.abs(this.target.y - y);

            if (xDist < 3 && yDist < 3) {
                return;
            }

            this.target.set(x, y, 0);
            this.lookatTarget();
        }

        let speed = 1;
        this.move = function () {
            let xDist = Math.abs(this.target.x - this.obj.position.x);
            let yDist = Math.abs(this.target.y - this.obj.position.y);

            if (xDist < 3 && yDist < 3) {
                return;
            }

            if (burner.box.containsPoint(this.target) && burner.box.intersectsBox(this.fullBox)) {
                return;
            }

            if (burner.box.distanceToPoint(this.obj.position) < 20) {
                for (let i = this.trash.length - 1; i >= 0; i--) {
                    let trash = this.trash[i];
                    this.obj.remove(trash.line);
                    delete trash;
                }
                this.trash = [];
                this.space = this.maxSpace;
            }

            this.lookatTarget();
            let moveY = Math.cos(this.vectorAngle) * speed;
            let moveX = Math.sin(this.vectorAngle) * speed * -1;
            this.obj.position.add(new THREE.Vector3(moveX, moveY, 0));
        }

        this.update = function() {
            this.box.setFromObject(this.ellipse);
            this.fullBox.setFromObject(this.obj);
        }

        this.pickup = function (trash) {
            this.space--;
            this.obj.add(trash.line);
            trash.line.position.set(0, -7, 0);
            this.trash.push(trash);
        }

        this.trash = [];

        this.maxSpace = 5;
        this.space = 5;
    }

    function Burner(scene) {

        let spriteMap = new THREE.TextureLoader().load("Images/Burner.png");
        let spriteMaterial = new THREE.SpriteMaterial({ map: spriteMap, color: 0xffffff });
        let sprite = new THREE.Sprite(spriteMaterial);

        sprite.scale.set(90, 90, 0);
        sprite.position.set(width - 47, 7, 2);

        this.obj = new THREE.Object3D();
        this.obj.add(sprite);

        scene.add(this.obj);

        this.box = new THREE.Box3(new THREE.Vector3(width - 100, 0, 0), new THREE.Vector3(width, 24, 0));
    }


    let topbar = document.getElementById("topbar");

    let boat = new Boat(scene);

    let burner = new Burner(scene);

    let allTrash = [];
    allTrash.push(new Trash(scene));

    let chance = 0.005;

    setInterval(function() {
        chance += 0.001;

        if (Math.random() <= chance) {
            allTrash.push(new Trash(scene));
        }
    }, 300);

    let isMoving = false;

    function handleMove(evt) {
        if (evt.buttons === 1) {
            boat.setTarget(evt.clientX * xScale, height - (evt.clientY * yScale));
        }
    }

    function handleTouchMove(evt) {
        boat.setTarget(evt.changedTouches[0].clientX * xScale, height - (evt.changedTouches[0].clientY * yScale));
    }

    function handleStart(evt) {
        boat.setTarget(evt.clientX * xScale, height - (evt.clientY * yScale));
        isMoving = true;
    }

    function handleEnd() {
        isMoving = false;
    }

    window.addEventListener("mousemove", handleMove);
    window.addEventListener("touchmove", handleTouchMove);

    window.addEventListener("mousedown", handleStart);
    window.addEventListener("touchstart", handleStart);

    window.addEventListener("mouseup", handleEnd);
    window.addEventListener("touchend", handleEnd);


    var animate = function () {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);

        boat.update();
        if (isMoving) {
            boat.move();
        }

        for (let i = allTrash.length - 1; i >= 0; i--) {
            let trash = allTrash[i];
            trash.update();

            if (boat.space > 0 && boat.box.containsBox(trash.box)) {
                scene.remove(trash.line);
                allTrash.splice(i, 1);
                boat.pickup(trash);
            } else if (trash.line.position.x > width + 10) {
                scene.remove(trash.line);
                allTrash.splice(i, 1);
                delete trash;
            }
        }

        topbar.innerHTML = "Room: " + boat.space;

    };

    animate();

</script>
</body>
</html>